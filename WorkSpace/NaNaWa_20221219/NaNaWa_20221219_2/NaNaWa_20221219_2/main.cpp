//#include <iostream>
//#include <bitset>
//
//int main()
//{
//	//변수: 메모리(램)에 공간을 만들고 해당공간에 값을 저장해서 사용할수 있게 해주는기능.
//	//자료형(Data Type) 
//	//정수형 : int char short long...
//	//실수형 : float double ...
//	
//	//int 4byte크기를 갖고있다.
//	//변수는 고정이 아니다 
//	//0 : 값이라고 부른다.
//	//= 대입연산자라고 부른다.
//	//Lvalue , RValue
//	
//	//int iNumber = 0;
//	//컴파일 과정에서(변수 ====> 메모리주소(ffbxxx))
//	
//	//기본컴퓨터 단위
//	//1bit 는 0,1 두가지를 표현할수 있고
//	//1Byte = 8Bit
//	
//	//1Kbyte =1024byte
//	//1mybyte = 1024kbyte
//	//1gbbyte = 1024mbyte
//	//1tbbyte = 1024gbyte
//
//	
//	
//	char ch = 48;  //1Byte  256가지를 표현가능
//	char ch2 = '48'; //작은따옴표는 한 문자를 표현
//	std::cout << ch << std::endl;
//	std::cout << ch2 << std::endl;
//
//	ch = 128;
//	//ch = 256 을 넣으니까 0 이나왔다  
//	//왜 0이나오는지?
//
//	//오버플로우(OverFlow)
//	//변수가 표현할수 있는 최대범위를 넘어가는 경우를 오버플로우현상이라고 한다.
//
//	//언더플로우(UnderFlow)
//	//변수가 표현할수 있는 최소의범위를 넘어가는 경우를 언더플로우라고 한다.
//
//	//애초에 자료형을 만들때 음수를 사용할지 안할지 결정해준다.
//	
//	//양수 ,음수를 다사용할거라면
//	char ch3 = 5;
//
//	//양수만 사용할거면 
//	unsigned char ch4 = 5;
//
//	//부호비트
//	//컴퓨터에서 마이너스를 표현할때는 
//	//1Byte의 기준으로 살펴보면 8개의 모든숫자를 저장하는게 아니라
//	//7개만 저장되고 비트1개는 음수 또는 양수인지 구별하게 된다.
//	//여기에서 양수와 음수를 구별할수 있는 비트는 부호 비트라고 부른다.
//
//	//MSB(Most Significant Bit) 최상위 비트 
//	//LSB(Least Significant Bit) 최하위 비트  
//
//	//LSB를 이용해서 짝수,홀수를 구별할수 있다.
//	//2진수로 생각했을때 
//	//==============================================================================
//	//0 -----> 0000		1 -----> 0001	2 ----> 0010	3 -----> 0011
//	//4 -----> 0100		5 -----> 0101	6 ----> 0110	7 -----> 0111	8 ----> 1000
//
//	//LSB는 0,1에 따라서 짝수 홀수를 알아낼수 있다.
//	//이걸 and연산의 특성을 사용하면 짝수인지 홀수 인지 바로알수있다.
//	//and연산 -> 두 숫자를 더했을때 모두 1일때 1 / 하나라도 0이면 0 
//
//	//결론 어떤수를 1과 and연산을 시켜서 결과가 0이면 짝수 1이면 홀수다.
//
//	//	ex)
//	//	0011	and 
//	//	0001
//	//  -----
//	//  0001
//
//	//수학에서는 정수를 음수,양수,0 으로 구분하지만 컴퓨터에서는 하나의 비트에 2가지만 표현할수 있어서 0은 양수로 취급한다.
//
//	signed char c4 = 255;  //-1  비트:1111 1111
//
//	unsigned char c5 = 255;    //255   비트:1111 1111
//	
//	//비트단위로 보기
//	std::cout << "c4:" << std::bitset<8>(c4) << std::endl;
//	std::cout << "c5:" << std::bitset<8>(c5) << std::endl;
//
//	//둘의 메모리 비트값은 똑같다
//	//255라는 숫자는 똑같이 1111 1111 로 채워져있다.
//	//근데 부호가 있는 마이너스를 채용하는 비트는 최상위비트 msb를 부호용도로 사용하고 있다. 
//	//결국은 어떤 관점으로 보느냐에 따라 다른 것이다.
//
//	//
//	unsigned char c6 = -1;
//
//	char c7 = 255;
//
//	//음수를 조금 쉽게 찾는법 
//	//2의보수법
//	//대응되는 양수의 부호를 반전시킨다(1의보수), 1의보수후에  +1을 더한다(2의보수)
//	//0 0 0 0 0 0 1 0 = 2 
//	//1 1 1 1 1 1 0 1  =>1.반전을 시킨다 
//	//1 1 1 1 1 1 1 0  =>2. +1을 더한다. 
//
//	//실수...
//	//정수형 실수형의 자료형을 나눈것은 처리하는 방식이 완전히 다르다.
//	//정수랑 실수는 표현하는 메모리방식 자체가 다르다는게 핵심!
//	//컴퓨터에서의 실수는 부동소수점을 사용한다.
//	//float fNumber = 3.f;
//
//	/*
//		변수의 타입 
//		타입			|		크기		|		표현종류		|	표현범위											|		unsigned				|
//		char			|	1byte			|		문자			|	-128 ~ 127											|		0 ~ 255					|
//		bool			|	1byte			|		참/거짓			|	false(0) ~true(1)									|								|
//		short			|	2byte			|		정수			|	-32,768 ~ 32,767									|		0 ~ 65,535				|
//		int				|	4byte			|		정수			|	-2,147,483,648 ~ 2,147,483,647						|		0 ~ 4,294,967,295		|
//		__int64			|	8byte			|		정수			|	-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807				|				|
//		float			|	4byte			|		실수			|
//		double			|	8byte			|		실수			|
//	*/
//
//	//bool 0은false , 0이 아닌 모든수는 true 
//
//	bool bTest = -5;
//	bool bTrue = 0;
//	std::cout << bTest << std::endl;
//	std::cout << bTrue << std::endl;
//
//	//short 타입 변수를 사용했을때 32768을 저장하면 이 값은 short의 표현범위를 벗어나서(over flow)-32768이 저장 된다.
//	short sTest = 32768;
//	std::cout << sTest << std::endl;
//
//	//
//	int iNumber = 244444;
//	//__int64 iBossHp = 29999999;
//
//	float fNumber2 = 5.6f;
//	double fNumber3 = 55.5;
//
//	//변수의 특징
//	//카멜 표기법 myName, fireMagic , bossRica , totalNumber 
//	//첫글자는 대문자로 적되 , 맨앞에 오는 글자는 소문자로 표기하는 방식
//	//낙타의 혹처럼 보인다고 카멜 표기법이라고 부른다.
//
//	//헝가리언 표기법 자료형을 확인하기 어려워서 변수이름을 정할때 앞에 변수의 특성을 알수 있게 접두어를 붙인다.
//	//i_data, fNumber , sh_Number,strName 등
//	//변수를 만들때는 변수이름만보고 자료형을 알수 있게 만드는것이 가장 좋다.
//
//	//암시적 명시적,연산자 다음주...
//
//	f
//
//	return 0;
//}